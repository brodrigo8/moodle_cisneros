{"version":3,"file":"mutations.min.js","sources":["../../../src/local/courseeditor/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport ajax from 'core/ajax';\nimport {add as addToast} from 'core/toast';\nimport {getString} from \"core/str\";\n\n/**\n * Default mutation manager\n *\n * @module     core_courseformat/local/courseeditor/mutations\n * @class     core_courseformat/local/courseeditor/mutations\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport default class {\n\n    // All course editor mutations for Moodle 4.0 will be located in this file.\n\n    /**\n     * Private method to call core_courseformat_update_course webservice.\n     *\n     * @method _callEditWebservice\n     * @param {string} action\n     * @param {number} courseId\n     * @param {array} ids\n     * @param {number} targetSectionId optional target section id (for moving actions)\n     * @param {number} targetCmId optional target cm id (for moving actions)\n     */\n    async _callEditWebservice(action, courseId, ids, targetSectionId, targetCmId) {\n        const args = {\n            action,\n            courseid: courseId,\n            ids,\n        };\n        if (targetSectionId) {\n            args.targetsectionid = targetSectionId;\n        }\n        if (targetCmId) {\n            args.targetcmid = targetCmId;\n        }\n        let ajaxresult = await ajax.call([{\n            methodname: 'core_courseformat_update_course',\n            args,\n        }])[0];\n        return JSON.parse(ajaxresult);\n    }\n\n    /**\n     * Execute a basic section state action.\n     * @param {StateManager} stateManager the current state manager\n     * @param {string} action the action name\n     * @param {array} sectionIds the section ids\n     * @param {number} targetSectionId optional target section id (for moving actions)\n     * @param {number} targetCmId optional target cm id (for moving actions)\n     */\n    async _sectionBasicAction(stateManager, action, sectionIds, targetSectionId, targetCmId) {\n        const course = stateManager.get('course');\n        const feedbackParams = this._getFeedbackParams(stateManager, 'section', sectionIds);\n        this.sectionLock(stateManager, sectionIds, true);\n        const updates = await this._callEditWebservice(\n            action,\n            course.id,\n            sectionIds,\n            targetSectionId,\n            targetCmId\n        );\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n        // Show the feedback message after performing the action.\n        await this._showFeedbackMessage(action, feedbackParams);\n    }\n\n    /**\n     * Execute a basic course module state action.\n     * @param {StateManager} stateManager the current state manager\n     * @param {string} action the action name\n     * @param {array} cmIds the cm ids\n     * @param {number} targetSectionId optional target section id (for moving actions)\n     * @param {number} targetCmId optional target cm id (for moving actions)\n     */\n    async _cmBasicAction(stateManager, action, cmIds, targetSectionId, targetCmId) {\n        const feedbackParams = this._getFeedbackParams(stateManager, 'cm', cmIds);\n        const course = stateManager.get('course');\n        this.cmLock(stateManager, cmIds, true);\n        const updates = await this._callEditWebservice(\n            action,\n            course.id,\n            cmIds,\n            targetSectionId,\n            targetCmId\n        );\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n        this.cmLock(stateManager, cmIds, false);\n        await this._showFeedbackMessage(action, feedbackParams);\n    }\n\n    /**\n     * Builds the object for the parameters of the feedback message lang string.\n     *\n     * @param {StateManager} stateManager The state manager\n     * @param {string} itemType The item type. Can be 'cm' for course modules or 'section' for course sections.\n     * @param {number[]} itemIds The item IDs. Can be the array of cm IDs or section IDs.\n     * @returns {{}}\n     * @private\n     */\n    _getFeedbackParams(stateManager, itemType, itemIds) {\n        const feedbackParams = {};\n        if (itemIds.length > 1) {\n            feedbackParams.count = itemIds.length;\n        } else if (itemIds.length === 1) {\n            const itemInfo = stateManager.get(itemType, itemIds[0]);\n            if (itemType === 'section') {\n                // For course sections, the section name is in the title property.\n                feedbackParams.name = itemInfo.title;\n            } else {\n                feedbackParams.name = itemInfo.name;\n            }\n        }\n        return feedbackParams;\n    }\n\n    /**\n     * Displays a toast containing the feedback message for the action that has been performed.\n     *\n     * @param {string} action The action that has been performed.\n     * @param {object} messageParams The parameters for the feedback lang string.\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _showFeedbackMessage(action, messageParams) {\n        let multi = '';\n        if (messageParams.count) {\n            multi = '_multi';\n        }\n        const toastMessage = await getString(`${action}_feedback${multi}`, 'core_courseformat', messageParams);\n        await addToast(toastMessage);\n    }\n\n    /**\n     * Mutation module initialize.\n     *\n     * The reactive instance will execute this method when addMutations or setMutation is invoked.\n     *\n     * @param {StateManager} stateManager the state manager\n     */\n    init(stateManager) {\n        // Add a method to prepare the fields when some update is comming from the server.\n        stateManager.addUpdateTypes({\n            prepareFields: this._prepareFields,\n        });\n    }\n\n    /**\n     * Add default values to state elements.\n     *\n     * This method is called every time a webservice returns a update state message.\n     *\n     * @param {Object} stateManager the state manager\n     * @param {String} updateName the state element to update\n     * @param {Object} fields the new data\n     * @returns {Object} final fields data\n     */\n    _prepareFields(stateManager, updateName, fields) {\n        // Any update should unlock the element.\n        fields.locked = false;\n        return fields;\n    }\n\n    /**\n     * Hides sections.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     */\n    async sectionHide(stateManager, sectionIds) {\n        await this._sectionBasicAction(stateManager, 'section_hide', sectionIds);\n    }\n\n    /**\n     * Show sections.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     */\n    async sectionShow(stateManager, sectionIds) {\n        await this._sectionBasicAction(stateManager, 'section_show', sectionIds);\n    }\n\n    /**\n     * Show cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmShow(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_show', cmIds);\n    }\n\n    /**\n     * Hide cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmHide(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_hide', cmIds);\n    }\n\n    /**\n     * Stealth cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmStealth(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_stealth', cmIds);\n    }\n\n    /**\n     * Duplicate course modules\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {number|undefined} targetSectionId the optional target sectionId\n     * @param {number|undefined} targetCmId the target course module id\n     */\n    async cmDuplicate(stateManager, cmIds, targetSectionId, targetCmId) {\n        const action = 'cm_duplicate';\n        const feedbackParams = this._getFeedbackParams(stateManager, 'cm', cmIds);\n        const course = stateManager.get('course');\n        // Lock all target sections.\n        const sectionIds = new Set();\n        if (targetSectionId) {\n            sectionIds.add(targetSectionId);\n        } else {\n            cmIds.forEach((cmId) => {\n                const cm = stateManager.get('cm', cmId);\n                sectionIds.add(cm.sectionid);\n            });\n        }\n        this.sectionLock(stateManager, Array.from(sectionIds), true);\n\n        const updates = await this._callEditWebservice(action, course.id, cmIds, targetSectionId, targetCmId);\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n\n        this.sectionLock(stateManager, Array.from(sectionIds), false);\n        await this._showFeedbackMessage(action, feedbackParams);\n    }\n\n    /**\n     * Move course modules to specific course location.\n     *\n     * Note that one of targetSectionId or targetCmId should be provided in order to identify the\n     * new location:\n     *  - targetCmId: the activities will be located avobe the target cm. The targetSectionId\n     *                value will be ignored in this case.\n     *  - targetSectionId: the activities will be appended to the section. In this case\n     *                     targetSectionId should not be present.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmids the list of cm ids to move\n     * @param {number} targetSectionId the target section id\n     * @param {number} targetCmId the target course module id\n     */\n    async cmMove(stateManager, cmids, targetSectionId, targetCmId) {\n        if (!targetSectionId && !targetCmId) {\n            throw new Error(`Mutation cmMove requires targetSectionId or targetCmId`);\n        }\n        const course = stateManager.get('course');\n        this.cmLock(stateManager, cmids, true);\n        const updates = await this._callEditWebservice('cm_move', course.id, cmids, targetSectionId, targetCmId);\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n        this.cmLock(stateManager, cmids, false);\n    }\n\n    /**\n     * Move course modules to specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids to move\n     * @param {number} targetSectionId the target section id\n     */\n    async sectionMove(stateManager, sectionIds, targetSectionId) {\n        if (!targetSectionId) {\n            throw new Error(`Mutation sectionMove requires targetSectionId`);\n        }\n        const course = stateManager.get('course');\n        this.sectionLock(stateManager, sectionIds, true);\n        const updates = await this._callEditWebservice('section_move', course.id, sectionIds, targetSectionId);\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n    }\n\n    /**\n     * Move course modules after a specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids to move\n     * @param {number} targetSectionId the target section id\n     */\n    async sectionMoveAfter(stateManager, sectionIds, targetSectionId) {\n        if (!targetSectionId) {\n            throw new Error(`Mutation sectionMoveAfter requires targetSectionId`);\n        }\n        const course = stateManager.get('course');\n        this.sectionLock(stateManager, sectionIds, true);\n        const updates = await this._callEditWebservice('section_move_after', course.id, sectionIds, targetSectionId);\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n    }\n\n    /**\n     * Add a new section to a specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {number} targetSectionId optional the target section id\n     */\n    async addSection(stateManager, targetSectionId) {\n        if (!targetSectionId) {\n            targetSectionId = 0;\n        }\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('section_add', course.id, [], targetSectionId);\n        stateManager.processUpdates(updates);\n    }\n\n    /**\n     * Delete sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of course modules ids\n     */\n    async sectionDelete(stateManager, sectionIds) {\n        const action = 'section_delete';\n        const feedbackParams = this._getFeedbackParams(stateManager, 'section', sectionIds);\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice(action, course.id, sectionIds);\n        this.bulkReset(stateManager);\n        stateManager.processUpdates(updates);\n        await this._showFeedbackMessage(action, feedbackParams);\n    }\n\n    /**\n     * Delete cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of section ids\n     */\n    async cmDelete(stateManager, cmIds) {\n        const action = 'cm_delete';\n        const feedbackParams = this._getFeedbackParams(stateManager, 'cm', cmIds);\n        const course = stateManager.get('course');\n        this.cmLock(stateManager, cmIds, true);\n        const updates = await this._callEditWebservice(action, course.id, cmIds);\n        this.bulkReset(stateManager);\n        this.cmLock(stateManager, cmIds, false);\n        stateManager.processUpdates(updates);\n        await this._showFeedbackMessage(action, feedbackParams);\n    }\n\n    /**\n     * Mark or unmark course modules as dragging.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} dragValue the new dragging value\n     */\n    cmDrag(stateManager, cmIds, dragValue) {\n        this.setPageItem(stateManager);\n        this._setElementsValue(stateManager, 'cm', cmIds, 'dragging', dragValue);\n    }\n\n    /**\n     * Mark or unmark course sections as dragging.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     * @param {bool} dragValue the new dragging value\n     */\n    sectionDrag(stateManager, sectionIds, dragValue) {\n        this.setPageItem(stateManager);\n        this._setElementsValue(stateManager, 'section', sectionIds, 'dragging', dragValue);\n    }\n\n    /**\n     * Mark or unmark course modules as complete.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} complete the new completion value\n     */\n    cmCompletion(stateManager, cmIds, complete) {\n        const newValue = (complete) ? 1 : 0;\n        this._setElementsValue(stateManager, 'cm', cmIds, 'completionstate', newValue);\n    }\n\n    /**\n     * Move cms to the right: indent = 1.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmMoveRight(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_moveright', cmIds);\n    }\n\n    /**\n     * Move cms to the left: indent = 0.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmMoveLeft(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_moveleft', cmIds);\n    }\n\n    /**\n     * Set cms group mode to NOGROUPS.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmNoGroups(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_nogroups', cmIds);\n    }\n\n    /**\n     * Set cms group mode to VISIBLEGROUPS.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmVisibleGroups(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_visiblegroups', cmIds);\n    }\n\n    /**\n     * Set cms group mode to SEPARATEGROUPS.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmSeparateGroups(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_separategroups', cmIds);\n    }\n\n    /**\n     * Lock or unlock course modules.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} lockValue the new locked value\n     */\n    cmLock(stateManager, cmIds, lockValue) {\n        this._setElementsValue(stateManager, 'cm', cmIds, 'locked', lockValue);\n    }\n\n    /**\n     * Lock or unlock course sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     * @param {bool} lockValue the new locked value\n     */\n    sectionLock(stateManager, sectionIds, lockValue) {\n        this._setElementsValue(stateManager, 'section', sectionIds, 'locked', lockValue);\n    }\n\n    _setElementsValue(stateManager, name, ids, fieldName, newValue) {\n        stateManager.setReadOnly(false);\n        ids.forEach((id) => {\n            const element = stateManager.get(name, id);\n            if (element) {\n                element[fieldName] = newValue;\n            }\n        });\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Set the page current item.\n     *\n     * Only one element of the course state can be the page item at a time.\n     *\n     * There are several actions that can alter the page current item. For example, when the user is in an activity\n     * page, the page item is always the activity one. However, in a course page, when the user scrolls to an element,\n     * this element get the page item.\n     *\n     * If the page item is static means that it is not meant to change. This is important because\n     * static page items has some special logic. For example, if a cm is the static page item\n     * and it is inside a collapsed section, the course index will expand the section to make it visible.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {String|undefined} type the element type (section or cm). Undefined will remove the current page item.\n     * @param {Number|undefined} id the element id\n     * @param {boolean|undefined} isStatic if the page item is static\n     */\n    setPageItem(stateManager, type, id, isStatic) {\n        let newPageItem;\n        if (type !== undefined) {\n            newPageItem = stateManager.get(type, id);\n            if (!newPageItem) {\n                return;\n            }\n        }\n        stateManager.setReadOnly(false);\n        // Remove the current page item.\n        const course = stateManager.get('course');\n        course.pageItem = null;\n        // Save the new page item.\n        if (newPageItem) {\n            course.pageItem = {\n                id,\n                type,\n                sectionId: (type == 'section') ? newPageItem.id : newPageItem.sectionid,\n                isStatic,\n            };\n        }\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Unlock all course elements.\n     *\n     * @param {StateManager} stateManager the current state manager\n     */\n    unlockAll(stateManager) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        state.section.forEach((section) => {\n            section.locked = false;\n        });\n        state.cm.forEach((cm) => {\n            cm.locked = false;\n        });\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Update the course index collapsed attribute of some sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} collapsed the new collapsed value\n     */\n    async sectionIndexCollapsed(stateManager, sectionIds, collapsed) {\n        const collapsedIds = this._updateStateSectionPreference(stateManager, 'indexcollapsed', sectionIds, collapsed);\n        if (!collapsedIds) {\n            return;\n        }\n        const course = stateManager.get('course');\n        await this._callEditWebservice('section_index_collapsed', course.id, collapsedIds);\n    }\n\n    /**\n     * Update the course index collapsed attribute of all sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {boolean} collapsed the new collapsed value\n     */\n    async allSectionsIndexCollapsed(stateManager, collapsed) {\n        const sectionIds = stateManager.getIds('section');\n        this.sectionIndexCollapsed(stateManager, sectionIds, collapsed);\n    }\n\n    /**\n     * Update the course content collapsed attribute of some sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} collapsed the new collapsed value\n     */\n    async sectionContentCollapsed(stateManager, sectionIds, collapsed) {\n        const collapsedIds = this._updateStateSectionPreference(stateManager, 'contentcollapsed', sectionIds, collapsed);\n        if (!collapsedIds) {\n            return;\n        }\n        const course = stateManager.get('course');\n        await this._callEditWebservice('section_content_collapsed', course.id, collapsedIds);\n    }\n\n    /**\n     * Private batch update for a section preference attribute.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {string} preferenceName the preference name\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} preferenceValue the new preferenceValue value\n     * @return {Number[]|null} sections ids with the preference value true or null if no update is required\n     */\n    _updateStateSectionPreference(stateManager, preferenceName, sectionIds, preferenceValue) {\n        stateManager.setReadOnly(false);\n        const affectedSections = new Set();\n        // Check if we need to update preferences.\n        sectionIds.forEach(sectionId => {\n            const section = stateManager.get('section', sectionId);\n            if (section === undefined) {\n                return null;\n            }\n            const newValue = preferenceValue ?? section[preferenceName];\n            if (section[preferenceName] != newValue) {\n                section[preferenceName] = newValue;\n                affectedSections.add(section.id);\n            }\n        });\n        stateManager.setReadOnly(true);\n        if (affectedSections.size == 0) {\n            return null;\n        }\n        // Get all collapsed section ids.\n        const collapsedSectionIds = [];\n        const state = stateManager.state;\n        state.section.forEach(section => {\n            if (section[preferenceName]) {\n                collapsedSectionIds.push(section.id);\n            }\n        });\n        return collapsedSectionIds;\n    }\n\n    /**\n     * Enable/disable bulk editing.\n     *\n     * Note: reenabling the bulk will clean the current selection.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {Boolean} enabled the new bulk state.\n     */\n    bulkEnable(stateManager, enabled) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        state.bulk.enabled = enabled;\n        state.bulk.selectedType = '';\n        state.bulk.selection = [];\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Reset the current selection.\n     * @param {StateManager} stateManager the current state manager\n     */\n    bulkReset(stateManager) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        state.bulk.selectedType = '';\n        state.bulk.selection = [];\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Select a list of cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    cmSelect(stateManager, cmIds) {\n        this._addIdsToSelection(stateManager, 'cm', cmIds);\n    }\n\n    /**\n     * Unselect a list of cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    cmUnselect(stateManager, cmIds) {\n        this._removeIdsFromSelection(stateManager, 'cm', cmIds);\n    }\n\n    /**\n     * Select a list of sections.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of cm ids\n     */\n    sectionSelect(stateManager, sectionIds) {\n        this._addIdsToSelection(stateManager, 'section', sectionIds);\n    }\n\n    /**\n     * Unselect a list of sections.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of cm ids\n     */\n    sectionUnselect(stateManager, sectionIds) {\n        this._removeIdsFromSelection(stateManager, 'section', sectionIds);\n    }\n\n    /**\n     * Add some ids to the current bulk selection.\n     * @param {StateManager} stateManager the current state manager\n     * @param {String} typeName the type name (section/cm)\n     * @param {array} ids the list of ids\n     */\n    _addIdsToSelection(stateManager, typeName, ids) {\n        const bulk = stateManager.state.bulk;\n        if (!bulk?.enabled) {\n            throw new Error(`Bulk is not enabled`);\n        }\n        if (bulk?.selectedType !== \"\" && bulk?.selectedType !== typeName) {\n            throw new Error(`Cannot add ${typeName} to the current selection`);\n        }\n\n        // Stored ids are strings for compatability with HTML data attributes.\n        ids = ids.map(value => value.toString());\n\n        stateManager.setReadOnly(false);\n        bulk.selectedType = typeName;\n        const newSelection = new Set([...bulk.selection, ...ids]);\n        bulk.selection = [...newSelection];\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Remove some ids to the current bulk selection.\n     *\n     * The method resets the selection type if the current selection is empty.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {String} typeName the type name (section/cm)\n     * @param {array} ids the list of ids\n     */\n    _removeIdsFromSelection(stateManager, typeName, ids) {\n        const bulk = stateManager.state.bulk;\n        if (!bulk?.enabled) {\n            throw new Error(`Bulk is not enabled`);\n        }\n        if (bulk?.selectedType !== \"\" && bulk?.selectedType !== typeName) {\n            throw new Error(`Cannot remove ${typeName} from the current selection`);\n        }\n\n        // Stored ids are strings for compatability with HTML data attributes.\n        ids = ids.map(value => value.toString());\n\n        stateManager.setReadOnly(false);\n        const IdsToFilter = new Set(ids);\n        bulk.selection = bulk.selection.filter(current => !IdsToFilter.has(current));\n        if (bulk.selection.length === 0) {\n            bulk.selectedType = '';\n        }\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Get updated state data related to some cm ids.\n     *\n     * @method cmState\n     * @param {StateManager} stateManager the current state\n     * @param {array} cmids the list of cm ids to update\n     */\n    async cmState(stateManager, cmids) {\n        this.cmLock(stateManager, cmids, true);\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('cm_state', course.id, cmids);\n        stateManager.processUpdates(updates);\n        this.cmLock(stateManager, cmids, false);\n    }\n\n    /**\n     * Get updated state data related to some section ids.\n     *\n     * @method sectionState\n     * @param {StateManager} stateManager the current state\n     * @param {array} sectionIds the list of section ids to update\n     */\n    async sectionState(stateManager, sectionIds) {\n        this.sectionLock(stateManager, sectionIds, true);\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('section_state', course.id, sectionIds);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n    }\n\n    /**\n     * Get the full updated state data of the course.\n     *\n     * @param {StateManager} stateManager the current state\n     */\n    async courseState(stateManager) {\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('course_state', course.id);\n        stateManager.processUpdates(updates);\n    }\n\n}\n"],"names":["action","courseId","ids","targetSectionId","targetCmId","args","courseid","targetsectionid","targetcmid","ajaxresult","ajax","call","methodname","JSON","parse","stateManager","sectionIds","course","get","feedbackParams","this","_getFeedbackParams","sectionLock","updates","_callEditWebservice","id","bulkReset","processUpdates","_showFeedbackMessage","cmIds","cmLock","itemType","itemIds","length","count","itemInfo","name","title","messageParams","multi","toastMessage","init","addUpdateTypes","prepareFields","_prepareFields","updateName","fields","locked","_sectionBasicAction","_cmBasicAction","Set","add","forEach","cmId","cm","sectionid","Array","from","cmids","Error","cmDrag","dragValue","setPageItem","_setElementsValue","sectionDrag","cmCompletion","complete","newValue","lockValue","fieldName","setReadOnly","element","type","isStatic","newPageItem","undefined","pageItem","sectionId","unlockAll","state","section","collapsed","collapsedIds","_updateStateSectionPreference","getIds","sectionIndexCollapsed","preferenceName","preferenceValue","affectedSections","size","collapsedSectionIds","push","bulkEnable","enabled","bulk","selectedType","selection","cmSelect","_addIdsToSelection","cmUnselect","_removeIdsFromSelection","sectionSelect","sectionUnselect","typeName","map","value","toString","newSelection","IdsToFilter","filter","current","has"],"mappings":"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"}
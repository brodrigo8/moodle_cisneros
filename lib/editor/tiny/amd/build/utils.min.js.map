{"version":3,"file":"utils.min.js","sources":["../src/utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {renderForPromise} from 'core/templates';\nimport {getFilePicker} from './options';\nimport {get_string as getString} from 'core/str';\n\n/**\n * Get the image path for the specified image.\n *\n * @param {string} identifier The name of the image\n * @param {string} component The component name\n * @return {string} The image URL path\n */\nexport const getImagePath = (identifier, component = 'editor_tiny') => Promise.resolve(M.util.image_url(identifier, component));\n\nexport const getButtonImage = async(identifier, component = 'editor_tiny') => renderForPromise('editor_tiny/toolbar_button', {\n    image: await getImagePath(identifier, component),\n});\n\n/**\n * Helper to display a filepicker and return a Promise.\n *\n * The Promise will resolve when a file is selected, or reject if the file type is not found.\n *\n * @param {TinyMCE} editor\n * @param {string} filetype\n * @returns {Promise<object>} The file object returned by the filepicker\n */\nexport const displayFilepicker = (editor, filetype) => new Promise((resolve, reject) => {\n    const configuration = getFilePicker(editor, filetype);\n    if (configuration) {\n        const options = {\n            ...configuration,\n            formcallback: resolve,\n        };\n        M.core_filepicker.show(Y, options);\n        return;\n    }\n    reject(`Unknown filetype ${filetype}`);\n});\n\n/**\n * Given a TinyMCE Toolbar configuration, add the specified button to the named section.\n *\n * @param {object} toolbar\n * @param {string} section\n * @param {string} button\n * @returns {object} The toolbar configuration\n */\nexport const addToolbarButton = (toolbar, section, button) => {\n    if (!toolbar) {\n        return [{\n            name: section,\n            items: [button],\n        }];\n    }\n\n    const mutatedToolbar = JSON.parse(JSON.stringify(toolbar));\n    return mutatedToolbar.map((item) => {\n        if (item.name === section) {\n            item.items.push(button);\n        }\n\n        return item;\n    });\n};\n\n/**\n * Given a TinyMCE Toolbar configuration, add the specified buttons to the named section.\n *\n * @param {object} toolbar\n * @param {string} section\n * @param {Array} buttons\n * @returns {object} The toolbar configuration\n */\nexport const addToolbarButtons = (toolbar, section, buttons) => {\n    if (!toolbar) {\n        return [{\n            name: section,\n            items: buttons,\n        }];\n    }\n\n    const mutatedToolbar = JSON.parse(JSON.stringify(toolbar));\n    return mutatedToolbar.map((item) => {\n        if (item.name === section) {\n            buttons.forEach(button => item.items.push(button));\n        }\n\n        return item;\n    });\n};\n\n/**\n * Insert a new section into the toolbar.\n *\n * @param {array} toolbar The TinyMCE.editor.settings.toolbar configuration\n * @param {string} name The new section name to add\n * @param {string} relativeTo Insert relative to this section name\n * @param {boolean} append Append or Prepend\n * @returns {array}\n */\nexport const addToolbarSection = (toolbar, name, relativeTo, append = true) => {\n    const newSection = {\n        name,\n        items: [],\n    };\n    const sectionInserted = toolbar.some((section, index) => {\n        if (section.name === relativeTo) {\n            if (append) {\n                toolbar.splice(index + 1, 0, newSection);\n            } else {\n                toolbar.splice(index, 0, newSection);\n            }\n            return true;\n        }\n        return false;\n    });\n\n    if (!sectionInserted) {\n        // Relative section not found.\n        if (append) {\n            toolbar.push(newSection);\n        } else {\n            toolbar.unshift(newSection);\n        }\n    }\n\n    return toolbar;\n};\n\n/**\n * Given a TinyMCE Menubar configuration, add the specified button to the named section.\n *\n * @param {object} menubar\n * @param {string} section\n * @param {string} menuitem\n * @returns {object}\n */\nexport const addMenubarItem = (menubar, section, menuitem) => {\n    if (!menubar) {\n        const emptyMenubar = {};\n        emptyMenubar[section] = {\n            title: section,\n            items: menuitem,\n        };\n    }\n\n    const mutatedMenubar = JSON.parse(JSON.stringify(menubar));\n    Array.from(Object.entries(mutatedMenubar)).forEach(([name, menu]) => {\n        if (name === section) {\n            menu.items = `${menu.items} ${menuitem}`;\n        }\n    });\n\n    return mutatedMenubar;\n};\n\n/**\n * Given a TinyMCE contextmenu configuration, add the specified button to the end.\n *\n * @param {string} contextmenu\n * @param {string[]} menuitems\n * @returns {string}\n */\nexport const addContextmenuItem = (contextmenu, ...menuitems) => {\n    const contextmenuItems = (contextmenu ?? '').split(' ');\n\n    return contextmenuItems\n        .concat(menuitems)\n        .filter((item) => item !== '')\n        .join(' ');\n};\n\n/**\n * Given a TinyMCE quickbars configuration, add items to the meun.\n *\n * @param {string} toolbar\n * @param {string[]} menuitems\n * @returns {string}\n */\n// eslint-disable-next-line no-unused-vars\nexport const addQuickbarsToolbarItem = (toolbar, ...menuitems) => {\n    // For the moment we have disabled use of this menu.\n    // The configuration is left in place to allow plugins to declare that they would like to support it in the future.\n    return toolbar;\n};\n\n/**\n * Get the link to the user documentation for the named plugin.\n *\n * @param {string} pluginName\n * @returns {string}\n */\nexport const getDocumentationLink = (pluginName) => `https://docs.moodle.org/en/editor_tiny/${pluginName}`;\n\n/**\n * Get the default plugin metadata for the named plugin.\n * If no URL is provided, then a URL is generated pointing to the standard Moodle Documentation.\n *\n * @param {string} component The component name\n * @param {string} pluginName The plugin name\n * @param {string|null} [url=null] An optional URL to the plugin documentation\n * @returns {object}\n */\nexport const getPluginMetadata = async(component, pluginName, url = null) => {\n    const name = await getString('helplinktext', component);\n    return {\n        getMetadata: () => ({\n            name,\n            url: url ?? getDocumentationLink(pluginName),\n        }),\n    };\n};\n\n/**\n * Ensure that the editor is still in the DOM, removing it if it is not.\n *\n * @param {TinyMCE} editor\n * @returns {TinyMCE|null}\n */\nexport const ensureEditorIsValid = (editor) => {\n    // TinyMCE uses the element ID as a map key internally, even if the target has changed.\n    // In cases such as where an editor is in a modal form which has been detached from the DOM, but the editor not removed,\n    // we need to manually destroy the editor.\n    // We could theoretically do this with a Mutation Observer, but in some cases the Node may be moved,\n    // or added back elsewhere in the DOM.\n    if (!editor?.targetElm?.closest('body')) {\n        editor.destroy();\n        return null;\n    }\n\n    return editor;\n};\n"],"names":["getImagePath","identifier","component","Promise","resolve","M","util","image_url","_exports","_ref","getButtonImage","_asyncToGenerator","_regeneratorRuntime","mark","_args","arguments","wrap","_context","prev","next","t0","renderForPromise","t1","sent","t2","image","abrupt","stop","_callee","_x","apply","this","displayFilepicker","editor","filetype","reject","configuration","getFilePicker","options","formcallback","core_filepicker","show","Y","concat","addToolbarButton","toolbar","section","button","JSON","parse","stringify","map","item","name","items","push","addToolbarButtons","buttons","forEach","addToolbarSection","relativeTo","append","newSection","sectionInserted","some","index","splice","unshift","addMenubarItem","menubar","menuitem","mutatedMenubar","Array","from","Object","entries","_ref2","_ref3","_slicedToArray","menu","addContextmenuItem","contextmenu","contextmenuItems","split","_len","length","menuitems","_key","filter","join","addQuickbarsToolbarItem","getDocumentationLink","pluginName","_ref4","getPluginMetadata","_callee2","url","_args2","_context2","getString","get_string","getMetadata","_x2","_x3","ensureEditorIsValid","_editor$targetElm","targetElm","closest","destroy"],"mappings":"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"}